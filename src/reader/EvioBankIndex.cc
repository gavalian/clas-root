/**
* Autogenerated Source File for EvioBankIndex
* \\file EvioBankIndex.cc
* \\author G.Gavalian
* \\date 2014-09-28
*/
#include "EvioBankIndex.h"


EvioBankIndex::EvioBankIndex()
{
}
/* 
EvioBankIndex::EvioBankIndex(const EvioBankIndex &obj)
{
}
*/
EvioBankIndex::~EvioBankIndex()
{
}


void  EvioBankIndex::initBankIndex(uint32_t *buffer){
	evioIndex.clear();
	parseBank(buffer,0xe,0,NULL);
}

/* const EvioBankIndex &EvioBankIndex::operator=(const EvioBankIndex &obj){} */

void *EvioBankIndex::leafHandler(int bankLength, int containerType, int contentType, uint16_t tag, uint8_t num, int depth, 
                                   const uint32_t *bankPointer, int dataLength, const void *data, void *userArg){
	//cout << "--------> Leaf Node :  TAG = " << tag << " NUM " << num 
	//	<< " TYPE = " << contentType << " DEPTH = " << depth << endl;
	bankIndex_t index;//(tag,num,contentType);
	index.set(tag,num,contentType,dataLength,0);
	index.data = data;
	evioIndex[index.getHash(tag,num)] = index;
	return ((void*) NULL);
}

void *EvioBankIndex::containerHandler(int bankLength, int containerType, int contentType, uint16_t tag, uint8_t num, int depth, 
                                        const uint32_t *bankPointer, int payloadLength, const uint32_t *payload, void *userArg)
{
	//cout << "---> Container Node :  TAG = " << tag << " NUM " << num 
	//	<< " TYPE = " << contentType << " DEPTH = " << depth << endl;
	return(NULL);
}

const void   *EvioBankIndex::getBank(uint32_t tag, uint8_t num, int *len){
	int key = indexInfo.getHash(tag,num);
	if(evioIndex.count(key)==0){
		*len = 0;
		return NULL;
	}
	bankIndex_t info = evioIndex[key];
	*len = info.length;
	return info.data;
}

void EvioBankIndex::list(){
	cout << "*********************************************************************" << endl;
	cout << "************************** EVIO BANK LIST ***************************" << endl;
	std::map<uint32_t,bankIndex_t>::iterator it;
	for(it = evioIndex.begin(); it!=evioIndex.end(); ++it){
		cout << "---> " << it->first << " " << it->second.getTag() 
			<< "  " << it->second.getNum() << "   " << it->second.data << endl;
	}
}

void *EvioBankIndex::parseBank(const uint32_t *buf, int bankType, int depth, 
                            void *userArg)  { //throw(evioException) {
	int length,dataOffset,p,bankLen;
  int contentType;
  uint16_t tag;
  uint8_t num;
  const uint32_t *data;
  uint32_t mask;
  int padding;

  void *newUserArg = userArg;


  /* get type-dependent info */
  switch(bankType) {

  case 0xe:
  case 0x10:
    length  	= buf[0]+1;
    tag     	= buf[1]>>16;
    contentType	= (buf[1]>>8)&0x3f;
    num     	= buf[1]&0xff;
    padding     = (buf[1]>>14)&0x3;
    dataOffset  = 2;
    //cout << " here " << endl;
    break;

  case 0xd:
  case 0x20:
    length  	= (buf[0]&0xffff)+1;
    tag     	= buf[0]>>24;
    contentType = (buf[0]>>16)&0x3f;
    num     	= 0;
    padding     = (buf[0]>>22)&0x3;
    dataOffset  = 1;
    break;
    
  case 0xc:
  case 0x40:
    length  	= (buf[0]&0xffff)+1;
    tag     	= buf[0]>>20;
    contentType	= (buf[0]>>16)&0xf;
    num     	= 0;
    padding     = 0;
    dataOffset  = 1;
    break;

  default:
  	throw "Error while deconding content types";
    //ostringstream ss;
    //ss << hex << showbase << bankType << noshowbase << dec;
    //throw(evioException(0,"?evioStreamParser::parseBank...illegal bank type: " + ss.str(),__FILE__,__FUNCTION__,__LINE__));
  }

  //cout << "PARSING BANK LENGHT = " << length << " TAG = " << tag << " CONTENT = " << contentType << endl; 
  /* 
   * if a leaf node, call leaf handler.
   * if container node, call node handler and then parse contained banks.
   * note:  padding refers to the number of extra bytes
   */

  void *newLeaf = NULL;
  switch (contentType) {

  case 0x0:
  case 0x1:
  case 0x2:
  case 0xb:
  case 0xf:
    // four-byte types
    newLeaf=leafHandler(length,bankType,contentType,tag,num,depth,&buf[0],length-dataOffset,&buf[dataOffset],userArg);
    break;

  case 0x3:
  case 0x6:
  case 0x7:
    // one-byte types
    newLeaf=leafHandler(length,bankType,contentType,tag,num,depth,&buf[0],(length-dataOffset)*4-padding,
                                    (int8_t*)(&buf[dataOffset]),userArg);
    break;

  case 0x4:
  case 0x5:
    // two-byte types
    newLeaf=leafHandler(length,bankType,contentType,tag,num,depth,
                                    &buf[0],(length-dataOffset)*2-padding/2,(int16_t*)(&buf[dataOffset]),userArg);
    break;

  case 0x8:
  case 0x9:
  case 0xa:
    // eight-byte types
    newLeaf=leafHandler(length,bankType,contentType,tag,num,depth,
                                    &buf[0],(length-dataOffset)/2,(int64_t*)(&buf[dataOffset]),userArg);
    break;

  case 0xe:
  case 0x10:
  case 0xd:
  case 0x20:
  case 0xc:
  case 0x40:
    // container types
    newUserArg=containerHandler(length,bankType,contentType,tag,num,depth,&buf[0],length-dataOffset,&buf[dataOffset],userArg);


    // parse contained banks
    p       = 0;
    bankLen = length-dataOffset;
    data    = &buf[dataOffset];
    mask    = ((contentType==0xe)||(contentType==0x10))?0xffffffff:0xffff;

    depth++;
    while(p<bankLen) {
      parseBank(&data[p],contentType,depth,newUserArg);
      p+=(data[p]&mask)+1;
    }
    depth--;

    break;


  default:
  	throw "Error in the final stage";
    //ostringstream ss;
    //ss << hex << showbase << contentType << noshowbase << dec;
    //throw(evioException(0,"?evioStreamParser::parseBank...illegal content type: " + ss.str(),__FILE__,__FUNCTION__,__LINE__));
    break;

  }


  // new user arg is pointer to new node
  if(newLeaf!=NULL) {
    return(newLeaf);
  } else {
    return(newUserArg);
  }

}